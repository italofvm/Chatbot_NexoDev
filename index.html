<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NexoBot - Assistente de IA</title>
    <!-- Carrega Tailwind CSS para estilização rápida e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- DOMPurify para sanitizar HTML vindo da IA (prevenção contra XSS) -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            min-height: 100vh;
        }
        
        /* O widget principal é fixo no canto inferior direito */
        #chat-widget-wrapper {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        /* O contêiner de chat (a janela que abre) */
        #chat-container {
            height: 500px; /* Altura padrão para um widget flutuante */
            width: 100%;
            max-width: 480px; /* Largura aumentada para o chatbox */
            
            /* Estado inicial: fechado (escondido) */
            transform: scale(0.5);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease-out;
            transform-origin: bottom right; /* Anima a partir do botão */
            
            /* Z-Index elevado para garantir que o chat fique acima de outros elementos */
            z-index: 1010; 
            /* Adiciona posição relativa para o botão de fechar interno */
            position: relative; 
        }

        #chat-container.open {
            /* Estado aberto */
            transform: scale(1);
            opacity: 1;
            pointer-events: auto;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        /* Estilos da janela de mensagens e bolhas */
        #chat-window {
            height: 100%;
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 80%;
            border-radius: 1.25rem; /* Um pouco mais arredondado para suavidade */
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        .user-message {
            background-color: #4f46e5; /* Indigo 600 */
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.5rem;
        }
        .bot-message {
            background-color: #e5e7eb; /* Gray 200 */
            color: #1f2937; /* Gray 800 */
            margin-right: auto;
            border-bottom-left-radius: 0.5rem;
        }
        /* Loading dots */
        .ai-loading-dot {
            width: 8px;
            height: 8px;
            background-color: #4f46e5;
            border-radius: 50%;
            display: inline-block;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .ai-loading-dot:nth-child(1) { animation-delay: -0.32s; }
        .ai-loading-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }
        
        .agent-card {
            transition: transform 0.2s, box-shadow 0.2s, opacity 0.2s;
        }
        /* Estilo para cartão clicável (Online) */
        .agent-card.active {
            cursor: pointer;
        }
        .agent-card.active:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        /* Estilo para cartão desabilitado (Ausente/Offline) */
        .agent-card.inactive {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #f3f4f6;
        }
        
        /* Status Dot */
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }
        
        /* FIX DO LAYOUT: Garante que a área de input tenha um padding inferior suficiente */
        #input-area {
            padding-bottom: 1rem; /* Volta ao padding padrão, pois o FAB X foi movido */
            position: relative; /* Para garantir o z-index correto dos elementos internos */
            z-index: 10;
        }
        
        /* Novo estilo para o FAB X (fechar) que agora está DENTRO do container do chat */
        #fab-close-button {
            position: absolute;
            bottom: 10px; /* Ajusta a posição */
            right: 10px;
            z-index: 20; /* Garante que fique acima de tudo, inclusive da barra de input */
        }
        
        /* O botão de alternar que fica fora do chat (FAB inicial) */
        #chat-toggle-button {
             z-index: 1020; 
        }

    </style>
</head>
<body class="p-0 m-0">

    <!-- Container Flutuante no Canto Inferior Direito -->
    <div id="chat-widget-wrapper" class="flex flex-col items-end">
        
        <!-- 1. Janela do Chat -->
        <div id="chat-container" class="bg-white rounded-2xl flex flex-col mb-4">
            
            <!-- Botão de Fechar Interno (NOVO LUGAR PARA O FAB X) -->
             <button id="fab-close-button" 
                    class="bg-indigo-600 text-white rounded-full shadow-xl flex items-center justify-center transition-colors duration-200 hover:bg-indigo-700"
                    style="width: 44px; height: 44px;">
                <!-- Icone de Chat Fechado (X) -->
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
            
            <!-- Chat Header -->
            <div class="p-4 bg-indigo-600 text-white rounded-t-2xl flex items-center shadow-md">
                <!-- Icone de Voltar/Menu -->
                <button id="back-button" class="p-1 mr-2 rounded-full hover:bg-indigo-700 transition-colors hidden" aria-label="Voltar para Seleção">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                    </svg>
                </button>
                <!-- Ícone de Atendente (User) -->
                <svg class="w-6 h-6 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                </svg>
                <!-- Nome do Agente -->
                <h1 id="agent-name-display" class="text-lg font-bold truncate">Assistente NexoDev</h1>
            </div>

            <!-- Agent Selection Screen (Mostra os agentes para escolha) -->
            <div id="agent-selection-screen" class="flex-grow p-4 space-y-4 overflow-y-auto">
                <!-- Conteúdo gerado via JavaScript -->
            </div>

            <!-- Main Chat Interface (Escondido até que um agente seja selecionado) -->
            <div id="main-chat-interface" class="flex-grow flex flex-col hidden">
                <!-- Chat Window (Messages) -->
                <div id="chat-window" class="flex-grow p-4 space-y-3">
                    <!-- Mensagens serão inseridas via JavaScript -->
                    <!-- Dica inicial será inserida/removida no JS -->
                </div>

                <!-- Input Area -->
                <div id="input-area" class="p-4 border-t border-gray-200">
                    <div id="loading-indicator" class="text-sm text-indigo-600 mb-2 hidden">
                        <span id="thinking-name"></span> digitando
                        <span class="ai-loading-dot"></span>
                        <span class="ai-loading-dot"></span>
                        <span class="ai-loading-dot"></span>
                    </div>
                    <div class="flex items-center relative">
                        <!-- Input field -->
                        <input type="text" id="user-input" placeholder="Pergunte sobre serviços, React, Node.js..."
                               class="flex-grow p-3 border border-gray-300 rounded-l-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-shadow">
                        <!-- Send Button -->
                        <button id="send-button"
                                class="px-4 py-3 bg-indigo-600 text-white font-semibold rounded-r-xl hover:bg-indigo-700 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Enviar
                        </button>
                    </div>
                </div>
            </div>
            
        </div>

        <!-- 2. Botão de Alternar (Floating Action Button - FAB) -->
        <button id="chat-toggle-button" 
                class="bg-indigo-600 text-white rounded-full shadow-2xl flex items-center justify-center transition-all duration-300 transform hover:scale-105"
                style="width: 60px; height: 60px;"> <!-- Z-index agora é controlado pelo wrapper -->
            <!-- Icone de Chat Aberto -->
            <svg id="toggle-icon-open" class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M3 14c0 4.418 4.03 8 9 8s9-3.582 9-8-4.03-8-9-8-9 3.582-9 8z"></path>
            </svg>
            <!-- Icone de Chat Fechado (X) -->
            <svg id="toggle-icon-close" class="w-8 h-8 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
        </button>
    </div>

    <script>
        // Configuração e Inicialização
        const chatWindow = document.getElementById('chat-window');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const loadingIndicator = document.getElementById('loading-indicator');
        const agentNameDisplay = document.getElementById('agent-name-display');
        const thinkingNameSpan = document.getElementById('thinking-name');

        const chatContainer = document.getElementById('chat-container');
        const chatToggleButton = document.getElementById('chat-toggle-button');
        const fabCloseButton = document.getElementById('fab-close-button'); 
        const iconOpen = document.getElementById('toggle-icon-open');
        const iconClose = document.getElementById('toggle-icon-close');
        
        const selectionScreen = document.getElementById('agent-selection-screen');
        const mainChatInterface = document.getElementById('main-chat-interface');
        const backButton = document.getElementById('back-button'); 
        
        const apiUrl = "/api/chat";

        // --- CONSTANTES DE TEMPO (em milissegundos) para a nova lógica ---
        const INACTIVITY_DURATION = 1800000;         // 30 minutos (para fechar o chat se inativo)
        const OFFLINE_DURATION_MS = 5 * 60 * 1000;  // 5 minutos (período offline curto)
        const ONLINE_MIN_MS = 2 * 60 * 60 * 1000;   // 2 horas
        const ONLINE_MAX_MS = 3 * 60 * 60 * 1000;   // 3 horas
        const ONLINE_RANGE_MS = ONLINE_MAX_MS - ONLINE_MIN_MS;

        // Variáveis de Estado
        let isGenerating = false; 
        let currentAgentName = ''; 
        let currentAgentSkill = ''; 
        let selectedAgent = null; 
        let inactivityTimeoutId = null; 
        let chatHistory = []; 
        let isChatInitialized = false; 
        let agentStatusUpdateInterval = null; // Para atualizar a lista de status periodicamente

        // --- SIMULAÇÃO DE DADOS DE AGENTES HUMANOS ---
        const RAW_AGENTS_DATA = [
            // Agentes Diurnos (8h às 17h59) - ALTA DISPONIBILIDADE
            { name: "Italo", role: "Desenvolvedor Front-end", skill: "Front-end, React, UI/UX, Vendas", shift: 'day' }, 
            { name: "João Paulo", role: "Desenvolvedor Back-end", skill: "Back-end, Node.js, Banco de Dados, APIs", shift: 'day' }, 
            { name: "Evellin", role: "Suporte Técnico", skill: "Suporte, Infraestrutura, Hospedagem, TI", shift: 'day' }, 
            
            // Agentes Noturnos (18h às 7h59) - DISPONIBILIDADE PADRÃO
            { name: "Carlos", role: "Especialista em APIs e Infra", skill: "Node.js, Back-end, APIs, Infraestrutura", shift: 'night' }, 
            { name: "Pedro", role: "Consultor UI/UX", skill: "Design UX/UI, Prototipagem, Estratégia Digital", shift: 'night' }, 
            
            // Agentes de Suporte (sem horário definido, para simular Ausente/Offline)
            { name: "Maria", role: "Consultora de Vendas", skill: "Vendas, Propostas, Fechamento", shift: 'any' }, 
        ];

        let AGENTS = []; // Lista de agentes processada com o timestamp 'lastActive'

        /**
         * Gera um hash simples e estável do nome para garantir a mesma duração de Online
         * para o mesmo agente na mesma sessão, simulando a persistência.
         */
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            return Math.abs(hash);
        }

        /**
         * Verifica o horário atual e define qual turno está ativo.
         * @returns {string} 'day' se for horário diurno (8h-17h59), 'night' se noturno (18h-7h59).
         */
        function getCurrentShift() {
            const now = new Date();
            const hour = now.getHours();
            
            // Horário Diurno: 8:00 (inclusive) até 17:59 (inclusive)
            if (hour >= 8 && hour < 18) {
                return 'day';
            }
            // Horário Noturno: 18:00 (inclusive) até 7:59 (inclusive)
            return 'night'; 
        }

        /**
         * Calcula o status simulado do agente com base na lógica de ciclo de 2-3h Online / 5m Offline.
         * @param {object} agent - O objeto do agente raw.
         * @returns {object} O agente com o status simulado e tempo para a próxima transição.
         */
        function calculateSimulatedStatus(agent) {
            const now = Date.now();
            
            // 1. Determina se está no turno ativo
            const currentShift = getCurrentShift();
            const isAgentInActiveShift = agent.shift === currentShift;

            if (!isAgentInActiveShift) {
                 // Fora do turno (Ex: agente noturno durante o dia) ou 'any'
                const nextShiftStart = agent.shift === 'day' ? '8h' : '18h';
                return {
                    ...agent,
                    simulatedStatus: agent.shift === 'any' ? 'Ausente' : `Offline (Volta às ${nextShiftStart})`,
                    timeToNextTransitionMs: 0, 
                    isClickable: false,
                    dotClass: agent.shift === 'any' ? 'bg-yellow-500' : 'bg-gray-400'
                };
            }

            // --- LÓGICA DE CICLO 2H-3H ONLINE / 5 MIN OFFLINE (SÓ PARA TURNOS ATIVOS) ---

            // 2. Define a duração ONLINE de forma estável (entre 2h e 3h)
            const seed = simpleHash(agent.name); 
            // Garante que o cálculo é robusto, usando Number()
            const agentOnlineDuration = Number(ONLINE_MIN_MS) + (seed % Number(ONLINE_RANGE_MS));
            const totalCycleDuration = agentOnlineDuration + Number(OFFLINE_DURATION_MS);
            
            // 3. Define um ponto de âncora estável (e.g., início do dia de trabalho ou midnight)
            const ANCHOR_TIME = new Date('2025-01-01T00:00:00Z').getTime(); 
            const offsetForAgent = (seed % totalCycleDuration);
            
            const elapsedTimeSinceAnchor = now - ANCHOR_TIME;
            
            // Posição real no ciclo repetitivo, ajustada pelo offset
            const positionInCycle = (elapsedTimeSinceAnchor + offsetForAgent) % totalCycleDuration;

            let simulatedStatus;
            let timeToNextTransitionMs;
            let dotClass;

            if (positionInCycle < agentOnlineDuration) {
                // Está dentro do longo período ONLINE
                simulatedStatus = 'Online agora';
                timeToNextTransitionMs = agentOnlineDuration - positionInCycle;
                dotClass = 'bg-green-500';
            } else {
                // Está dentro do curto período OFFLINE (últimos 5 minutos do ciclo)
                // CORREÇÃO: Garante que o remainingMs seja um número válido e não negativo
                const remainingMs = Math.max(0, Number(totalCycleDuration) - Number(positionInCycle));
                const minutesRemaining = Math.ceil(remainingMs / 60000);

                simulatedStatus = `Offline (${minutesRemaining} min restantes)`;
                timeToNextTransitionMs = remainingMs;
                dotClass = 'bg-red-500';
            }
            
            return {
                ...agent,
                simulatedStatus: simulatedStatus,
                timeToNextTransitionMs: timeToNextTransitionMs,
                isClickable: simulatedStatus === 'Online agora', // Apenas clicável se "Online agora"
                dotClass: dotClass,
            };
        }


        /**
         * Inicializa a lista de AGENTS processando a lógica do novo ciclo de tempo.
         */
        function initializeAgents() {
            // Recalcula o status de todos os agentes
            AGENTS = RAW_AGENTS_DATA.map(raw => calculateSimulatedStatus(raw));
            
            // Ordena: Online no topo, depois Ausente/Offline por turno.
            AGENTS.sort((a, b) => {
                // Prioriza quem está clicável (Online agora)
                if (a.isClickable && !b.isClickable) return -1;
                if (!a.isClickable && b.isClickable) return 1;
                
                // Se o status for o mesmo, a ordem não importa tanto.
                return 0;
            });
            
             // Se o chat estiver aberto na seleção, atualiza a tela
            if (chatContainer.classList.contains('open') && !selectedAgent) {
                renderSelectionScreen();
            }
        }
        
        // Inicia o intervalo de atualização do status a cada 60 segundos
        function startStatusUpdater() {
            if (agentStatusUpdateInterval) clearInterval(agentStatusUpdateInterval);
            // Atualiza a cada 60 segundos para re-calcular o status e o tempo restante
            agentStatusUpdateInterval = setInterval(initializeAgents, 60000); 
        }

        // --- Funções de Lógica do Widget ---

        /**
         * Limpa o timer anterior e configura um novo.
         * Se o chat estiver aberto, ele fechará após INACTIVITY_DURATION.
         */
        function resetInactivityTimer() {
            clearTimeout(inactivityTimeoutId);
            if (chatContainer.classList.contains('open')) {
                inactivityTimeoutId = setTimeout(() => {
                    // Quando o timer expira, fecha o chat e reseta a conversa
                    toggleChat(true); 
                    goBackToSelection();
                }, INACTIVITY_DURATION);
            }
        }
        
        /**
         * Converte a formatação Markdown (incluindo #, listas e texto) para HTML limpo.
         */
        function handleMarkdownToHtml(text) {
            let formattedText = text;

            // 1. Converte Headers (#, ##, ...) em <strong> e remove o #
            formattedText = formattedText.replace(/^#{1,6}\s*(.*)$/gm, '<strong>$1</strong>');

            // 2. Converte [link text](url) para <a>
            formattedText = formattedText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" class="underline hover:text-indigo-800">$1</a>');

            // 3. Converte **bold** para <strong> (Prioriza a conversão para <strong>)
            formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); 

            // 4. Converte *italics* ou _italics_ para <em> 
            formattedText = formattedText.replace(/\*(.*?)\*/g, '<em>$1</em>'); 
            formattedText = formattedText.replace(/\_(.*?)\_/g, '<em>$1</em>'); 
            
            // 5. Tratamento de listas (converte bullets comuns (*, -, +) no início de uma linha para lista HTML)
            formattedText = formattedText.replace(/(\r\n|\r|\n)[\*\-\+]\s*(.*)/g, '$1&bull; $2');
            
            // 6. Quebras de linha (\n) para <br>
            formattedText = formattedText.replace(/\n/g, '<br>');

            return formattedText;
        }

        /**
         * Lida apenas com a renderização da bolha na UI.
         */
        function addMessageToUi(text, isUser, rawText = null) {
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex ${isUser ? 'justify-end' : 'justify-start'}`;

            const messageBubble = document.createElement('div');
            messageBubble.className = `message-bubble shadow-lg ${isUser ? 'user-message' : 'bot-message'}`;

            let formattedText = isUser ? text : handleMarkdownToHtml(text);
            
            // Tratamento de citações/grounding (simplificado para fins de exemplo)
            if (!isUser && rawText) {
                try {
                    const result = JSON.parse(rawText);
                    const candidate = result.candidates?.[0];
                    let sources = [];

                    if (candidate && candidate.groundingMetadata && candidate.groundingMetadata.groundingAttributions) {
                        sources = candidate.groundingMetadata.groundingAttributions
                            .map(attr => ({
                                uri: attr.web?.uri,
                                title: attr.web?.title,
                            }))
                            .filter(source => source.uri && source.title); 
                    }

                    if (sources.length > 0) {
                        const sourceList = sources.slice(0, 3).map((source) => {
                            let domain;
                            try {
                                domain = new URL(source.uri).hostname.replace('www.', '');
                            } catch {
                                domain = source.uri.substring(0, 30) + '...';
                            }

                            return `<li class="mt-1"><a href="${source.uri}" target="_blank" class="underline hover:text-indigo-800">${source.title} (${domain})</a></li>`;
                        }).join('');

                        formattedText += `<br><br><div class="pt-2 border-t border-gray-300 text-xs font-semibold">Fonte(s):<ul class="list-disc pl-5 font-normal">${sourceList}</ul></div>`;
                    }
                } catch (e) {
                    console.error("Erro ao analisar rawText para citações:", e);
                }
            }

            // Sanitiza o HTML antes de inserir para evitar XSS caso a IA retorne HTML/links
            if (window.DOMPurify && typeof DOMPurify.sanitize === 'function') {
                messageBubble.innerHTML = DOMPurify.sanitize(formattedText, { USE_PROFILES: { html: true } });
            } else {
                // Fallback: insere como texto (menos recursos visuais)
                messageBubble.textContent = formattedText.replace(/<br>/g, '\n');
            }
            messageWrapper.appendChild(messageBubble);
            chatWindow.appendChild(messageWrapper);
            
            // Rolar para a última mensagem
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /**
         * Adiciona uma mensagem ao histórico e a renderiza na UI.
         */
        function addMessage(text, isUser, rawText = null) {
            chatHistory.push({
                text: text,
                isUser: isUser,
                rawText: rawText,
                timestamp: Date.now()
            });

            addMessageToUi(text, isUser, rawText);
        }
        
        /**
         * Desenha as mensagens na janela de chat a partir do histórico.
         */
        function renderChatHistory() {
            chatWindow.innerHTML = '';
            
            if (!isChatInitialized) {
                chatWindow.innerHTML = `<div id="welcome-tip" class="text-center text-sm text-gray-500 italic p-2 border-b mb-4">
                        Diga algo para ${selectedAgent.name} e inicie a conversa.
                    </div>`;
            } else {
                chatHistory.forEach(msg => {
                    addMessageToUi(msg.text, msg.isUser, msg.rawText);
                });
            }

            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /**
         * Reseta o estado e volta para a tela de seleção.
         */
        function goBackToSelection() {
            selectedAgent = null;
            currentAgentName = '';
            currentAgentSkill = ''; 
            chatHistory = []; 
            isChatInitialized = false; 

            // Re-renderiza a lista de agentes para atualizar o status
            initializeAgents(); 
            renderSelectionScreen(); 
            
            selectionScreen.classList.remove('hidden');
            mainChatInterface.classList.add('hidden');
            backButton.classList.add('hidden'); 

            agentNameDisplay.textContent = "Escolha um Especialista";
        }


        /**
         * Renderiza a tela de seleção de agentes.
         */
        function renderSelectionScreen() {
            agentNameDisplay.textContent = "Escolha um Especialista";
            
            if (AGENTS.length === 0) initializeAgents();
            
            selectionScreen.innerHTML = `
                <p class="text-gray-700 text-center mb-6">Selecione o especialista que está <strong>Online</strong> para iniciar a conversa:</p>
            `;

            AGENTS.forEach(agent => {
                const { simulatedStatus, dotClass, isClickable } = agent;
                
                const card = document.createElement('div');
                card.className = `agent-card p-4 bg-gray-50 border border-gray-200 rounded-xl flex items-center shadow-sm hover:bg-white ${isClickable ? 'active' : 'inactive'}`;
                card.innerHTML = `
                    <div class="flex-shrink-0 w-10 h-10 bg-indigo-200 rounded-full flex items-center justify-center text-indigo-700 font-bold text-lg mr-4">
                        ${agent.name[0]}
                    </div>
                    <div class="flex-grow">
                        <p class="font-semibold text-gray-900">${agent.name}</p>
                        <p class="text-sm text-indigo-600">${agent.role}</p>
                    </div>
                    <div class="text-right flex flex-col items-end">
                        <span class="flex items-center text-xs font-medium text-gray-600">
                            <span class="status-dot ${dotClass}"></span>
                            ${simulatedStatus}
                        </span>
                    </div>
                `;
                
                if (isClickable) {
                    card.addEventListener('click', () => selectAgent(agent.name));
                }
                
                selectionScreen.appendChild(card);
            });
        }

        /**
         * Seleciona um agente e inicia a interface de chat.
         * @param {string} name - Nome do agente selecionado.
         */
        function selectAgent(name) {
            if (AGENTS.length === 0) initializeAgents();
            
            selectedAgent = AGENTS.find(a => a.name === name);

            if (!selectedAgent || !selectedAgent.isClickable) {
                return;
            }

            currentAgentName = selectedAgent.name; // Usa apenas o primeiro nome
            currentAgentSkill = selectedAgent.skill; 
            
            selectionScreen.classList.add('hidden');
            mainChatInterface.classList.remove('hidden');

            initializeChat(true); 
            userInput.focus();
        }


        /**
         * Inicializa o chat (carrega histórico ou reseta se expirado).
         * @param {boolean} forceReset - Se true, força o reset do histórico/estado.
         */
        function initializeChat(forceReset = false) {
            if (!selectedAgent) {
                backButton.classList.add('hidden');
                return;
            }

            backButton.classList.remove('hidden'); 
            
            const timeSinceLastMessage = chatHistory.length > 0 ? (Date.now() - chatHistory[chatHistory.length - 1].timestamp) : INACTIVITY_DURATION + 1;
            const isTimeoutExpired = timeSinceLastMessage > INACTIVITY_DURATION;

            if (forceReset || isTimeoutExpired) {
                chatHistory = []; 
                isChatInitialized = false; 
            }
            
            agentNameDisplay.textContent = selectedAgent.name;
            thinkingNameSpan.textContent = selectedAgent.name;

            renderChatHistory(); 
        }


        /**
         * Alterna a visibilidade da janela de chat.
         * @param {boolean} forceClose - Se true, força o fechamento.
         */
        function toggleChat(forceClose = false) {
            const isOpening = !chatContainer.classList.contains('open');

            if (forceClose || !isOpening) {
                 // Ao fechar
                clearTimeout(inactivityTimeoutId);
                chatContainer.classList.remove('open');
                chatToggleButton.classList.remove('hidden'); // Mostra o botão FAB
                
                // FAB interno (X) agora é acionado pelo toggle
                iconOpen.classList.remove('hidden');
                iconClose.classList.add('hidden');
                
                // Adiciona um prompt de satisfação ao histórico (se houve interação substancial)
                if (chatHistory.length > 1) { 
                    const feedbackPromptText = 'Espero ter ajudado! Lembre-se, sua <strong>satisfação</strong> é muito importante para nós. Se precisar agendar uma conversa, use nossos links de contato.';

                    const lastMessage = chatHistory[chatHistory.length - 1];
                    if (!lastMessage.text.includes('satisfação é muito importante') && !lastMessage.text.includes('Para finalizar seu agendamento')) {
                         chatHistory.push({
                            text: feedbackPromptText,
                            isUser: false,
                            timestamp: Date.now(),
                            rawText: null
                        });
                    }
                }
            } else if (isOpening) {
                // Ao abrir
                chatContainer.classList.add('open');
                chatToggleButton.classList.add('hidden'); // Esconde o botão FAB
                
                // FAB interno (X) agora é acionado pelo toggle
                iconOpen.classList.add('hidden');
                iconClose.classList.remove('hidden');
                
                if (!selectedAgent || (chatHistory.length === 0 && !isChatInitialized)) {
                    // Se estiver abrindo e não há agente selecionado ou o chat expirou/está vazio, volta para seleção
                    goBackToSelection();
                } else {
                    selectionScreen.classList.add('hidden');
                    mainChatInterface.classList.remove('hidden');
                    initializeChat(false); 
                    userInput.focus();
                }
            }

            // Reinicia o timer se estiver aberto.
            resetInactivityTimer();
        }

        // Links de Agendamento (Movido para fora do callGeminiApi para simplificar)
        const schedulingLinks = `
            Ótimo! Para finalizar seu agendamento, preciso transferir você para um dos nossos consultores no canal de sua preferência. Assim, garantimos que todos os detalhes e horários sejam acertados com precisão.
            
            <br>
            <span class="block mt-2">
                &bull; <strong>WhatsApp:</strong> <a href="https://wa.me/5599999999999" target="_blank" class="underline hover:text-indigo-800">Clique para iniciar uma conversa!</a>
            </span>
            <span class="block mt-1">
                &bull; <strong>Instagram:</strong> <a href="https://instagram.com/nexodev" target="_blank" class="underline hover:text-indigo-800">@NexoDev</a> (Mensagem Direta)
            </span>
            <br>
            
            Ficamos à disposição!
        `;

        /**
         * Lida com o erro da API e exibe uma mensagem no chat.
         */
        function handleApiError(error) {
            console.error("Erro da API Gemini:", error);
            addMessage("Desculpe, houve um erro de comunicação com a IA. Por favor, tente novamente.", false);
        }

        /**
         * Função principal para chamar a API Gemini.
         */
        async function callGeminiApi(prompt, maxRetries = 3) {
            
            const apiHistory = chatHistory.map(msg => ({
                role: msg.isUser ? "user" : "model",
                parts: [{ text: msg.text }]
            }));
            
            apiHistory.push({ role: "user", parts: [{ text: prompt }] });


            // System Prompt CRÍTICO
            const systemPrompt = `Você é o '${currentAgentName}', um assistente simpático e especialista da NexoDev (Desenvolvimento Web de Alto Impacto). 
                
                **SEU CAMPO DE ESPECIALIZAÇÃO (Skill):** ${currentAgentSkill}
                
                **SUA MISSÃO PRINCIPAL:** Responder às dúvidas do cliente sobre Landing Pages, sites de agendamento, React, Node.js e os serviços da NexoDev com clareza e sem jargões complexos, focando em vendas e consultoria. Você deve dar mais atenção e profundidade aos tópicos que se alinham com sua especialização: **${currentAgentSkill}**.
                
                **REGRA DE INÍCIO DE CONVERSA (CRÍTICO):**
                - Se for a primeira vez que você responde (chatHistory.length == 1, ou seja, só tem a mensagem do usuário, e o isChatInitialized foi recém-definido), você DEVE começar a resposta com a mensagem de boas-vindas formatada abaixo, seguida pelo resto da sua resposta normal.
                - Mensagem de Boas-Vindas: "Oi! Eu sou ${selectedAgent.name}, e estou aqui para te ajudar com qualquer dúvida sobre a NexoDev e como podemos criar ou melhorar o seu site. Sou especialista em **${selectedAgent.role}**, focando em: **${currentAgentSkill}**. Sinta-se à vontade para perguntar o que quiser!"

                **REGRAS DE AGENDAMENTO/TRANSFERÊNCIA (CRÍTICO):**
                1.  **NÃO** ofereça os links de agendamento (WhatsApp/Instagram) no início ou no meio da discussão.
                2.  Você deve oferecer a transferência **APENAS** se o cliente:
                    a)  Perguntar: "Quero agendar agora", "Quero falar com um humano", ou "Podemos finalizar o agendamento?".
                    b)  Você sentir que a discussão técnica/informativa sobre o projeto foi **esgotada** e o próximo passo lógico é o agendamento.
                3.  **SE** a regra (2) for atendida, você DEVE responder **EXCLUSIVAMENTE** com a seguinte mensagem (e nada mais):
                    
                    \`\`\`TRANSFER_TO_AGENT\`\`\`

                **REGRAS DE CONVERSA:**
                -   Responda sempre em Português.
                -   Use o formato **texto** para negrito.
                -   NUNCA repita a mensagem de boas-vindas "Oi! Eu sou..." se a conversa já tiver mais de uma rodada.
            `;
            
            const payload = {
                contents: apiHistory,
                tools: [{ "google_search": {} }], 
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        const candidate = result.candidates?.[0];

                        if (candidate && candidate.content?.parts?.[0]?.text) {
                            const text = candidate.content.parts[0].text.trim();
                            
                            if (text.includes('TRANSFER_TO_AGENT')) {
                                return { text: schedulingLinks, rawResponse: null };
                            }

                            return { text, rawResponse: JSON.stringify(result) };

                        } else {
                            throw new Error("Resposta da API vazia ou malformada.");
                        }
                    }

                    const delay = Math.pow(2, i) * 1000 + (Math.random() * 1000); 
                    await new Promise(resolve => setTimeout(resolve, delay));

                } catch (error) {
                    console.warn(`Tentativa ${i + 1} falhou.`, error);
                }
            }

            throw new Error("Todas as tentativas de API falharam após o backoff exponencial.");
        }


        /**
         * Lida com o envio da mensagem pelo usuário.
         */
        async function handleSend() {
            if (!selectedAgent) {
                goBackToSelection();
                return;
            }

            const prompt = userInput.value.trim();
            if (prompt === '' || isGenerating) return;

            addMessage(prompt, true);
            userInput.value = '';

            if (!isChatInitialized) {
                isChatInitialized = true;
                const tipElement = document.getElementById('welcome-tip');
                if (tipElement) {
                    tipElement.remove();
                }
            }
            
            isGenerating = true;
            loadingIndicator.classList.remove('hidden'); 
            sendButton.disabled = true;

            try {
                const { text, rawResponse } = await callGeminiApi(prompt);
                
                const minDelay = 1500; 
                const charsPerMs = 50;
                const calculatedDelay = Math.max(minDelay, text.length * charsPerMs);

                await new Promise(resolve => setTimeout(resolve, calculatedDelay));
                
                addMessage(text, false, rawResponse);

            } catch (error) {
                handleApiError(error);
            } finally {
                isGenerating = false;
                loadingIndicator.classList.add('hidden'); 
                sendButton.disabled = false;
                userInput.focus(); 
                
                resetInactivityTimer();
            }
        }

        // --- Event Listeners ---

        // Botão de Alternar o Chat (FAB de abrir/fechar o container)
        chatToggleButton.addEventListener('click', () => {
             try {
                toggleChat(false);
            } catch (error) {
                console.error("Erro ao alternar o chat:", error);
            }
        });
        
        // Botão de Fechar Interno (O FAB X que agora fica DENTRO do container)
        fabCloseButton.addEventListener('click', () => {
            try {
                toggleChat(true); // Força o fechamento
            } catch (error) {
                console.error("Erro ao fechar o chat:", error);
            }
        });

        // Botão de Voltar para a Seleção
        backButton.addEventListener('click', goBackToSelection);

        // Botão de Enviar
        sendButton.addEventListener('click', handleSend);

        // Tecla Enter no input
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); 
                handleSend();
            }
        });

        /**
         * Inicializa a aplicação ao carregar a página
         */
        window.onload = () => {
             startStatusUpdater();
        }

    </script>
</body>
</html>